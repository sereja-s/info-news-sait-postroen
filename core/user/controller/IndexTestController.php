<?php

namespace core\user\controller;

use core\admin\model\Model;
use core\base\controller\BaseController;

/** 
 * Индексный контроллер пользовательской части (для тестов)
 */
class IndexTestController extends BaseUser
{

	// Выпуск №12
	//use trait1;
	//use trait2;
	//use trait1, trait2;
	//use trait1, trait2 {
	// если трейты имеют одноимённые методы, необходимо указать метод какого трейта является приоритетным
	// например можем записать-  методом: who() 1-го трейта заменить одноимённый метод 2-го трейта
	//trait1::who insteadof trait2;
	// или наоборот
	//trait2::who insteadof trait1;
	//}

	//use trait1, trait2 {
	// что бы пользоваться методами обоих трейдов, необходимо методу трейта, который заменили дать псевдоним
	// теперь этот метод можно вызыввать по псевдониму
	//trait1::who insteadof trait2;
	// (псевдоним можно объявить только для метода, который уже переопределён (замещён) иным метоодом !!!)
	//trait2::who as who2;
	//}

	protected function inputData()
	{
		// Выпуск №120
		parent::inputData();

		// ================= трансляция от 28 окт. 2019 г. Тема: рекурсия при работе с категориями ===================//

		// выберем всё из таблицы категорий в массив в переменной:
		$res = $this->model->get('category', [
			// отсортируем все категории относительно родителей по порядку (при этом вначале пришли все родители, потом 
			// последовательно пришли все потомки(подкатегории) и затем подкатегории подкатегорий) 
			'order' => ['id', 'parent_id']
		]);

		// на вход 2-ой параметр подавать не обязательно, т.к. по умолчанию он зависан равным null
		$arr = $this->recurse($res);

		//-------------------------------------------------------------------------------------------------------------//

		// рассмотрим вариант несортированной выборки (когда данные приходт свалкой)
		$resAllSort =  $this->model->get('category');

		$arrAllSort = $this->recurseAllSort($resAllSort);



		//=============================================================================================================//

		// Выпуск №125
		$goods = $this->model->getGoods();

		// Выпуск №124
		/* $years = $this->wordsForCounter(50384);
		$a = 1; */

		// Выпуск №121
		$alias = '';
		$res1 = $this->alias();
		$res2 = $this->alias('catalog');
		$res3 = $this->alias('catalog', '?page=2');
		// допустили ошибку в адресе
		$res4 = $this->alias('catalog//auto', '?page=2');
		$res5 = $this->alias(['catalog' => 'auto'], '?page=2');
		$res5 = $this->alias(['catalog' => 'auto', 'girl' => 'Maria'], '?page=2');
		$res6 = $this->alias(['catalog' => 'auto', 'girl' => 'Maria'], 'page=2');
		$res7 = $this->alias(['catalog' => 'auto', 'girl' => 'Maria'], ['page' => 1, 'order' => 'desc']);


		// Выпуск №121
		// $res = $this->img(false, true);


		echo $this->getController();
		exit;
	}

	/** 
	 * Метод (рекурсивный) для работы с таблицей категорий с несколькими вложенностями подкатегорий
	 * на вход: 1- массив, который будем обходить; 2- ключ (родительский идентификатор, т.е. указатель в какой элемент собирать текущие элемеенты)
	 * 
	 * Примечание: метод работает только с изначально структурированными данными и позволяет получить выборку, удобную 
	 * т.е. отсортированную для дальнешего применения этих данных
	 */
	public function recurse($arr, $parent_id = null)
	{
		// определим результирующий массив
		$res_arr = [];

		foreach ($arr as $key => $item) {

			if ($item['parent_id'] === $parent_id) {

				// в начале собираем в массив элементы у которых в ячейке: parent_id установлено значение: null				
				$res_arr[$item['id']] = $item;

				// разрегистрируем(удалим) ячейку массива с которой уже отработали (чтобы на новых итерациях её опять не обходить):
				unset($arr[$key]);

				// затем когда условие не выполнится (закончатся все элементы с parent_id = null) переходим в часть else
			} else {

				// проверим существует ли уже ячейка родителя в результирующем массиве
				if (isset($res_arr[$item['parent_id']])) {

					// ячейку положим результат работы этого же метода, но 2-ым параметром здесь подаём то что хранится в  ячейке: $item['parent_id']
					// таким образом для данного родителя мы соберём все подкатегории, являющиеся дочерними ей
					$res_arr[$item['parent_id']]['sub'] = $this->recurse($arr, $item['parent_id']);
				}
			}
		}

		// обязательно надо что то вернуть (это и будет терминальное условие выхода из рекурсии)
		return $res_arr;
	}

	/** 
	 * Метод (рекурсивный) универсальный (работает как не сортированным массивом так и с отсортированным любым способом)
	 */
	public function recurseAllSort($arr, $parent_id = null)
	{
		// определим результирующий массив
		$res_arr = [];

		// функция php: reset() сбрасывает(переводит) указатель с текущего элемента массива на первый(нулевой) элемент 
		// массива (т.е. каждый раз массив будет обходиться с нулевого элемента) Это необходимо для работы с циклом: while
		reset($arr);

		// функция php: list() присваивает переменным из списка переданного в качестве параметров, значения (которые 
		// возвращает метод: each) подобные  массиву. Функция php: each() возвращает текущую пару(ключ=>значение) из 
		// массива и устнавливает указатель массива на следующий элемент (на данный момент она устарела и её лучше не использовать)
		/* while (list($key, $item) = each($arr)) {
		} */

		$key = key($arr);

		while ($key !== null) {

			//$flag = false;

			if ($arr[$key]['parent_id'] === $parent_id) {

				$res_arr[$arr[$key]['id']] = $arr[$key];

				unset($arr[$key]);

				reset($arr);

				$key = key($arr);

				//$flag = true;
				continue;
			} else {

				if (isset($res_arr[$arr[$key]['parent_id']])) {

					$res_arr[$arr[$key]['parent_id']]['sub'] = $this->recurseAllSort($arr, $arr[$key]['parent_id']);
				}
			}

			//if (!$flag) {

			next($arr);

			$key = key($arr);
			//}
		}

		return $res_arr;
	}
}

//--------------------------------------------------------------------------------------------------------------------//

// Случай 1: Отсутствует $value 
//reset($array);

//while (list($key, ) = each($array)) {

//Обновляется до:

//foreach(array_keys($array) as $key) {

//--------------------------------------------------------------//

//Случай 2: Отсутствует $key 
//reset($array);

//while (list(, $value) = each($array)) {

//Обновляется до:

//foreach($array as $value) {

//--------------------------------------------------------------//

//Случай 3: Ничего не пропущено
//reset($array);

//while (list($key, $value) = each($array)) {

//Обновляется до:

//foreach($array as $key => $value) {

//---------------------------------------------------------------//
